Replicated Datatypes

Folie 1

- the very core of a database are the datatypes
- we want to describe how such a datatype behaves
- we want to do that in a rigorous, exact way in order to reason about datatypes
- first, we want to look at how we could formalise the behaviour of a datatype
	- a datatype has a type, a set of operations and a value from a set Val
- the client requests those operations without knowing on which replica they are performed (transparent)

Folie 2

- we can specify a function that specifies the return value of an operation based on a sequence of previous operations
	- explaining the generic function
- we only look at one single object at a time
- in a strongly consistent system, concurrent operations on a single object are executed atomically in some order
- first, we look at a sequence of operations in a strongly consistent system (examples intreg, ctr)
	- S_ctr(sigma rd) = (number of inc operations in sigma), same for the int register

Folie 3

- extending the formalism to replicated data types is a bit more complicated
- operations on a single object can happen on concurrently on multiple replicas
	- example picture explained: D returns 3 whereas F returns 2
- Four strategies to deal with these incosistencies: (explain using the figure)
	- make operations commutative: Order does not matter, sequential behaviour. Possible for counters, not for intregs
	- Order concurrent operations: The system totally orders all operations, e.g. using timestamps (-> Interval Tree Clocks)
	- Flag conflicts: The system detects incosistencies and flags them for the user to deal with; in the figure, D would return {2,3}
	- Resolve conflicts Semantically : The system detects incosistencies and semantically resolves it (e.g. orset)
- We need a stronger function than S_{\tau} to specify these data types

Folie 4

- Instead of a sequence of operations, the result depends on operations that are visible in the given context (C is visible to D, not to E)
- Just like S_{\tau}, we want F_{\tau} to determine the return value of an operation based on prior operations on the object
- We also need additional information of the order of events (Relations ar and vis)
- We therefore get an operation context C = (f, V, ar, vis) 
- vis and ar describe, how operations in set V relate to each other
- because of C, the function F_{\tau} is completely deterministic (all non-determinism is in C)

Folie 5

- Example strategy 1: Counter  
	- vis and ar do not matter
- Example strategy 2: Int Register
	- ar is used to order events

